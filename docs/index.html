<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 데이터 생성 클라이언트 성능 최적화</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&family=JetBrains+Mono:wght@400;600&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        @page {
            size: A4;
            margin: 20mm;
        }
        
        body {
            font-family: 'Noto Sans KR', sans-serif;
            line-height: 1.8;
            color: #2c3e50;
            background: white;
            font-size: 11pt;
            margin: 0;
            padding: 0;
        }
        
        .container {
            max-width: 210mm;
            margin: 0 auto;
            padding: 20px;
            background: white;
            box-sizing: border-box;
        }
        
        /* 비디오 컨테이너 스타일 */
        .video-container {
            position: relative;
            width: 100%;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .video-container video {
            width: 100%;
            height: auto;
            display: block;
            border-radius: 8px;
        }
        
        /* 비디오 로딩 오버레이 */
        .video-loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 14px;
            display: none;
        }
        
        /* 모바일 반응형 스타일 */
        @media screen and (max-width: 768px) {
            body {
                font-size: 14px;
            }
            
            .container {
                padding: 15px;
                max-width: 100%;
            }
            
            h1 {
                font-size: 22px;
                line-height: 1.3;
            }
            
            h2 {
                font-size: 18px;
                margin-top: 25px;
            }
            
            h3 {
                font-size: 16px;
            }
            
            h4 {
                font-size: 14px;
            }
            
            .subtitle {
                font-size: 12px;
            }
            
            .tech-tags {
                gap: 8px;
            }
            
            .tech-tag {
                padding: 4px 10px;
                font-size: 11px;
            }
            
            table {
                font-size: 12px;
            }
            
            th, td {
                padding: 8px 10px;
            }
            
            .code-block {
                padding: 15px;
                font-size: 11px;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
            
            .highlight-box {
                padding: 15px;
            }
            
            .key-points {
                padding: 15px;
            }
            
            .process-flow {
                padding: 12px 15px;
            }
            
            .result-card {
                padding: 20px;
            }
            
            div[style*="grid-template-columns"] {
                display: flex !important;
                flex-direction: column !important;
                gap: 10px !important;
            }
        }
        
        @media screen and (max-width: 480px) {
            body {
                font-size: 13px;
            }
            
            .container {
                padding: 10px;
            }
            
            h1 {
                font-size: 20px;
            }
            
            h2 {
                font-size: 16px;
            }
            
            h3 {
                font-size: 14px;
            }
            
            .code-block {
                font-size: 10px;
                padding: 10px;
            }
            
            table {
                display: block;
                overflow-x: auto;
                white-space: nowrap;
            }
            
            .tech-tags {
                flex-wrap: wrap;
            }
            
            .process-flow li {
                padding-left: 30px;
            }
            
            .process-flow li::before {
                width: 20px;
                height: 20px;
                font-size: 10px;
            }
        }
        
        /* Header Styles */
        .header {
            border-bottom: 3px solid #3498db;
            padding-bottom: 15px;
            margin-bottom: 30px;
        }
        
        h1 {
            font-size: 24pt;
            color: #2c3e50;
            font-weight: 700;
            margin-bottom: 10px;
        }
        
        .subtitle {
            color: #7f8c8d;
            font-size: 11pt;
            font-weight: 400;
        }
        
        /* Section Styles */
        h2 {
            font-size: 16pt;
            color: #2980b9;
            margin-top: 35px;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 2px solid #e0e0e0;
            page-break-after: avoid;
        }
        
        h3 {
            font-size: 13pt;
            color: #34495e;
            margin-top: 25px;
            margin-bottom: 12px;
            font-weight: 600;
            page-break-after: avoid;
        }
        
        h4 {
            font-size: 11pt;
            color: #5a6c7d;
            margin-top: 20px;
            margin-bottom: 10px;
            font-weight: 600;
        }
        
        /* Content Styles */
        p {
            margin-bottom: 12px;
            text-align: justify;
        }
        
        .highlight-box {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin: 25px 0;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }
        
        .highlight-box strong {
            color: #ffd700;
        }
        
        /* Code Blocks */
        .code-block {
            background: #282c34;
            color: #abb2bf;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 10pt;
            line-height: 1.5;
            overflow-x: auto;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            page-break-inside: avoid;
            tab-size: 2;
            -moz-tab-size: 2;
            -webkit-tab-size: 2;
        }
        
        .code-block pre {
            margin: 0;
            padding: 0;
            tab-size: 2;
            -moz-tab-size: 2;
            -webkit-tab-size: 2;
        }
        
        /* Process Flow */
        .process-flow {
            background: #f8f9fa;
            border-left: 4px solid #3498db;
            padding: 15px 20px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }
        
        .process-flow ol {
            counter-reset: step;
            list-style: none;
        }
        
        .process-flow li {
            counter-increment: step;
            margin-bottom: 10px;
            position: relative;
            padding-left: 35px;
        }
        
        .process-flow li::before {
            content: counter(step);
            position: absolute;
            left: 0;
            top: 0;
            background: #3498db;
            color: white;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 10pt;
        }
        
        /* Performance Table */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 25px 0;
            box-shadow: 0 2px 15px rgba(0,0,0,0.08);
            page-break-inside: avoid;
        }
        
        thead {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        th {
            padding: 15px;
            text-align: left;
            font-weight: 600;
            font-size: 10pt;
        }
        
        td {
            padding: 12px 15px;
            border-bottom: 1px solid #e0e0e0;
            font-size: 10pt;
        }
        
        tbody tr:hover {
            background: #f5f6fa;
        }
        
        tbody tr:last-child td {
            border-bottom: none;
        }
        
        .improvement {
            color: #27ae60;
            font-weight: bold;
        }
        
        /* Key Points */
        .key-points {
            background: #ecf0f1;
            padding: 20px;
            border-radius: 10px;
            margin: 25px 0;
        }
        
        .key-points ul {
            list-style: none;
            padding-left: 0;
        }
        
        .key-points li {
            padding-left: 30px;
            margin-bottom: 10px;
            position: relative;
        }
        
        .key-points li::before {
            content: "✔";
            position: absolute;
            left: 0;
            color: #27ae60;
            font-weight: bold;
            font-size: 14pt;
        }
        
        /* Result Card */
        .result-card {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            padding: 25px;
            border-radius: 15px;
            margin: 30px 0;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
        }
        
        .result-card h3 {
            color: #2c3e50;
            margin-top: 0;
        }
        
        /* Tech Stack Tags */
        .tech-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 15px 0;
        }
        
        .tech-tag {
            background: #3498db;
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 9pt;
            font-weight: 500;
        }
        
        /* Visitor Counter Styles */
        .visitor-counter {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 8px 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 1000;
            font-size: 9pt;
            min-width: 120px;
        }
        
        .visitor-counter h4 {
            margin: 0 0 5px 0;
            color: #7f8c8d;
            font-size: 9pt;
            font-weight: 500;
            text-align: center;
        }
        
        .counter-item {
            display: flex;
            justify-content: space-between;
            margin: 3px 0;
            align-items: center;
            font-size: 8pt;
        }
        
        .counter-label {
            color: #95a5a6;
        }
        
        .counter-value {
            font-weight: 600;
            color: #2c3e50;
            font-size: 9pt;
        }
        
        .counter-loading {
            text-align: center;
            color: #bdc3c7;
            font-size: 8pt;
            padding: 3px;
        }
        
        /* Video View Counter */
        .video-views {
            margin-top: 8px;
            text-align: right;
            color: #7f8c8d;
            font-size: 9pt;
        }
        
        .video-views .view-count {
            font-weight: 600;
            color: #3498db;
        }
        
        @media screen and (max-width: 768px) {
            .visitor-counter {
                position: fixed;
                top: 10px;
                right: 10px;
                padding: 6px 10px;
                min-width: 100px;
            }
            
            .visitor-counter h4 {
                font-size: 8pt;
            }
            
            .counter-item {
                font-size: 7pt;
            }
            
            .counter-value {
                font-size: 8pt;
            }
        }
        
        /* Page Break Control */
        .page-break {
            page-break-after: always;
        }
        
        /* Print Styles */
        @media print {
            body {
                print-color-adjust: exact;
                -webkit-print-color-adjust: exact;
            }
            
            .container {
                padding: 0;
            }
            
            .code-block {
                break-inside: avoid;
            }
        }
    </style>
</head>
<body>
    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-V71NHMSRQZ"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-V71NHMSRQZ');
    </script>
    
    <!-- 방문자 카운터 -->
    <div class="visitor-counter">
        <h4>방문자</h4>
        <div id="counter-content">
            <div class="counter-loading">로딩 중...</div>
        </div>
    </div>
    
    <div class="container">
        <div class="header">
            <h1>AI 데이터 생성 클라이언트 성능 최적화</h1>
            <div class="subtitle">Unity HDRP 환경에서의 대규모 객체 세그멘테이션 처리 최적화</div>
        </div>
        
        <h2>📋 프로젝트 개요</h2>
        <div class="highlight-box">
            <p><strong>목적:</strong> 영상 분석 AI용 객체 탐지 대규모 데이터셋 생성</p>
            <p><strong>문제:</strong> 기존 0.5초의 객체 처리 속도로는 대규모 데이터셋 구축 불가</p>
            <p><strong>목표:</strong> 가상 데이터 생성의 핵심 장점인 "단시간 대규모 데이터 구축" 실현</p>
        </div>
        
        <div class="tech-tags">
            <span class="tech-tag">Unity HDRP</span>
            <span class="tech-tag">C#</span>
            <span class="tech-tag">HLSL</span>
            <span class="tech-tag">OpenCV</span>
            <span class="tech-tag">Shader Programming</span>
        </div>

        <h2>🔍 병목점 분석</h2>
        
        <h3>Unity Profiler 분석 결과</h3>
        <div class="key-points">
            <ul>
                <li><strong>GPU-CPU 간 데이터 전송(ReadPixels) 반복 호출</strong>이 주요 병목</li>
                <li>OpenCV 이미지 처리 과정에서 지연 발생</li>
                <li>객체 수에 비례한 선형적 처리 시간 증가</li>
            </ul>
        </div>

        <h3>기존 방식의 비효율성</h3>
        <div class="process-flow">
            <h4>객체별 개별 처리 플로우</h4>
            <ol>
                <li>특정 객체만 흰색으로 변경, 나머지는 검은색</li>
                <li>화면 캡처 (ReadPixels 호출)</li>
                <li>OpenCV로 이미지 처리하여 객체 데이터 추출</li>
                <li>하나의 이미지 (프로세스)에 있는 객체의 수만큼 반복</li>
            </ol>
            <p style="margin-top: 15px;">
                <strong>처리 시간:</strong> 객체 수 × 0.5초 (100개 = 50초)<br>
                <strong>메모리:</strong> 객체 수만큼 텍스처 생성으로 가변적 증가
            </p>
        </div>

        <h2>💡 최적화 솔루션</h2>
        
        <h3>핵심 아이디어: 다중 객체 동시 처리</h3>
        <div class="process-flow" style="background: #e8f5e9; border-left-color: #27ae60;">
            <h4>개선된 방식</h4>
            <ol>
                <li>모든 객체에 고유 색상 매핑 (빨강, 파랑, 초록 등)</li>
                <li>1회 캡처로 모든 객체 정보 획득</li>
                <li>색상별로 OpenCV 이미지 처리 일괄 수행</li>
            </ol>
            <p style="margin-top: 15px;">
                <strong>처리 시간:</strong> 객체 수와 무관하게 일정 (100개 = 5초)<br>
                <strong>메모리:</strong> 1회 캡처로 텍스처 생성 횟수 고정
            </p>
        </div>

        <h3>기술적 구현</h3>
        
        <h4>1. 고유 색상 생성 시스템</h4>
        <div class="code-block">
<pre style="color: #d4d4d4; margin: 0;"><span style="color: #569cd6;">public</span> <span style="color: #569cd6;">static</span> <span style="color: #569cd6;">class</span> <span style="color: #4ec9b0;">RandomUniqueColorGenerator</span>
{
    <span style="color: #569cd6;">private</span> <span style="color: #569cd6;">static</span> <span style="color: #4ec9b0;">HashSet</span>&lt;<span style="color: #4ec9b0;">Color32</span>&gt; <span style="color: #9cdcfe;">UniqueColorSet</span> = <span style="color: #569cd6;">new</span> <span style="color: #4ec9b0;">HashSet</span>&lt;<span style="color: #4ec9b0;">Color32</span>&gt;();

    <span style="color: #569cd6;">public</span> <span style="color: #569cd6;">static</span> <span style="color: #4ec9b0;">Color</span> <span style="color: #dcdcaa;">GetUniqueColor</span>()
    {
        <span style="color: #4ec9b0;">Color32</span> <span style="color: #9cdcfe;">rgb</span>;
        
        <span style="color: #c586c0;">do</span> 
        {
            <span style="color: #9cdcfe;">rgb</span> = <span style="color: #569cd6;">new</span> <span style="color: #4ec9b0;">Color32</span>(
                (<span style="color: #569cd6;">byte</span>)<span style="color: #4ec9b0;">Random</span>.<span style="color: #dcdcaa;">Range</span>(<span style="color: #b5cea8;">1</span>, <span style="color: #b5cea8;">255</span>), 
                (<span style="color: #569cd6;">byte</span>)<span style="color: #4ec9b0;">Random</span>.<span style="color: #dcdcaa;">Range</span>(<span style="color: #b5cea8;">1</span>, <span style="color: #b5cea8;">255</span>), 
                (<span style="color: #569cd6;">byte</span>)<span style="color: #4ec9b0;">Random</span>.<span style="color: #dcdcaa;">Range</span>(<span style="color: #b5cea8;">1</span>, <span style="color: #b5cea8;">255</span>), 
                <span style="color: #b5cea8;">255</span>
            );
        } 
        <span style="color: #c586c0;">while</span> (!<span style="color: #9cdcfe;">UniqueColorSet</span>.<span style="color: #dcdcaa;">Add</span>(<span style="color: #9cdcfe;">rgb</span>)); <span style="color: #6a9955;">// 중복 색상 방지</span>
        
        <span style="color: #c586c0;">return</span> <span style="color: #9cdcfe;">rgb</span>;
    }
}</pre>
        </div>
        <p><strong>핵심 아이디어:</strong> HashSet으로 중복 방지하여 각 객체마다 고유한 색상 보장</p>
        
        <!-- 영상 데모 섹션 1 -->
        <div style="background: #f8f9fa; border: 2px solid #3498db; border-radius: 10px; padding: 20px; margin: 20px 0;">
            <h5 style="color: #2c3e50; margin-top: 0; margin-bottom: 15px; text-align: center;">
                🎥 색상 포맷 이슈 발견 및 해결
            </h5>
            
            <!-- 로컬 비디오 -->
            <div class="video-container">
                <video controls preload="metadata" poster="./assets/thumbnails/GenerateUniqueColor.png" data-video-id="GenerateUniqueColor">
                    <source src="./assets/videos/GenerateUniqueColor.mov" type="video/quicktime">
                    <source src="./assets/videos/GenerateUniqueColor.mp4" type="video/mp4">
                    브라우저가 비디오 재생을 지원하지 않습니다.
                </video>
                <div class="video-loading">로딩 중...</div>
            </div>
            <div class="video-views">조회수: <span class="view-count">0</span>회</div>
            
            <p style="margin-top: 15px; margin-bottom: 10px; color: #5a6c7d; text-align: center;">
                <strong>테스트 내용:</strong> HSV와 RGB 포맷 변환 시 색상 중복 문제 검증
            </p>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 15px;">
                <div style="background: #fee5e5; border-radius: 6px; padding: 12px;">
                    <p style="margin: 0; font-size: 9pt; color: #c0392b;">
                        <strong>❌ 문제 발견</strong><br>
                        HSV → RGB 변환 시 서로 다른 HSV 값이 동일한 RGB로 매핑되는 현상 확인
                    </p>
                </div>
                <div style="background: #e8f5e9; border-radius: 6px; padding: 12px;">
                    <p style="margin: 0; font-size: 9pt; color: #27ae60;">
                        <strong>✅ 해결 방안</strong><br>
                        RGB32 포맷으로 통일하여 색상 중복 완전 방지
                    </p>
                </div>
            </div>
            
            <div style="background: linear-gradient(90deg, #e74c3c 0%, #3498db 100%); 
                        color: white; 
                        border-radius: 6px; 
                        padding: 12px; 
                        margin-top: 15px;">
                <p style="margin: 0; font-size: 10pt; text-align: center;">
                    💡 <strong>핵심 개선:</strong> HSV 포맷 제거, RGB32 단일 포맷 채택으로 색상 고유성 100% 보장
                </p>
            </div>
        </div>
        
        <!-- OpenCV 색상 추출 테스트 영상 -->
        <div style="background: #fff3e0; border: 2px solid #f39c12; border-radius: 10px; padding: 20px; margin: 20px 0;">
            <h5 style="color: #2c3e50; margin-top: 0; margin-bottom: 15px; text-align: center;">
                🔍 OpenCV 색상 추출 검증 테스트
            </h5>
            
            <!-- 로컬 비디오 -->
            <div class="video-container">
                <video controls preload="metadata" poster="./assets/thumbnails/OpenCV_Test.png" data-video-id="OpenCV_Test">
                    <source src="./assets/videos/OpenCV_Test.mov" type="video/quicktime">
                    <source src="./assets/videos/OpenCV_Test.mp4" type="video/mp4">
                    브라우저가 비디오 재생을 지원하지 않습니다.
                </video>
                <div class="video-loading">로딩 중...</div>
            </div>
            <div class="video-views">조회수: <span class="view-count">0</span>회</div>
            
            <p style="margin-top: 15px; margin-bottom: 10px; color: #5a6c7d; text-align: center;">
                <strong>테스트 내용:</strong> 다중 색상 이미지에서 특정 색상만 정확히 추출하는 OpenCV 처리 검증
            </p>
            
            <div style="display: flex; gap: 10px; margin-top: 15px;">
                <div style="flex: 1; background: #fef5e7; border-radius: 6px; padding: 10px;">
                    <p style="margin: 0; font-size: 9pt; color: #e67e22;">
                        📊 <strong>처리 과정:</strong><br>
                        1. 전체 이미지 캡처<br>
                        2. RGB 색상별 마스킹<br>
                        3. 객체 영역 추출
                    </p>
                </div>
                <div style="flex: 1; background: #e8f5e9; border-radius: 6px; padding: 10px;">
                    <p style="margin: 0; font-size: 9pt; color: #27ae60;">
                        ✅ <strong>검증 결과:</strong><br>
                        • 색상 정확도: 100%<br>
                        • 처리 속도: 0.1초 이내<br>
                        • 경계선 정밀도 확인
                    </p>
                </div>
            </div>
        </div>

        <div class="page-break"></div>

        <h4>2. 객체별 세그멘테이션 관리 시스템</h4>
        <div class="code-block">
<pre style="color: #d4d4d4; margin: 0;"><span style="color: #569cd6;">public</span> <span style="color: #569cd6;">class</span> <span style="color: #4ec9b0;">ObjectSegmentationProvider</span> : <span style="color: #4ec9b0;">MonoBehaviour</span>
{
    <span style="color: #569cd6;">public</span> <span style="color: #569cd6;">enum</span> <span style="color: #4ec9b0;">SegmentationMode</span>
    {
        <span style="color: #4fc1ff;">Default</span>  = <span style="color: #b5cea8;">0</span>,
        <span style="color: #4fc1ff;">Instance</span> = <span style="color: #b5cea8;">1</span>,
        <span style="color: #4fc1ff;">Semantic</span> = <span style="color: #b5cea8;">2</span>, 
        <span style="color: #4fc1ff;">Parts</span>    = <span style="color: #b5cea8;">3</span>,
        <span style="color: #4fc1ff;">Panoptic</span> = <span style="color: #b5cea8;">4</span>,
        <span style="color: #4fc1ff;">Outline</span>  = <span style="color: #b5cea8;">5</span>
    }

    <span style="color: #569cd6;">private</span> <span style="color: #4ec9b0;">Color</span> <span style="color: #9cdcfe;">instanceColor</span>;
    <span style="color: #569cd6;">private</span> <span style="color: #4ec9b0;">List</span>&lt;(<span style="color: #4ec9b0;">Color</span> color, <span style="color: #569cd6;">string</span> name)&gt; <span style="color: #9cdcfe;">partsColors</span>;
    <span style="color: #569cd6;">private</span> <span style="color: #4ec9b0;">List</span>&lt;<span style="color: #4ec9b0;">RendererSet</span>&gt; <span style="color: #9cdcfe;">rendererSets</span> = <span style="color: #569cd6;">new</span>();

    <span style="color: #569cd6;">public</span> <span style="color: #569cd6;">void</span> <span style="color: #dcdcaa;">SetupFoundations</span>(<span style="color: #569cd6;">bool</span> <span style="color: #9cdcfe;">isMap</span>, <span style="color: #4ec9b0;">Color</span> <span style="color: #9cdcfe;">classColor</span> = <span style="color: #569cd6;">default</span>)
    {
        <span style="color: #9cdcfe;">segmentationShader</span> = <span style="color: #4ec9b0;">Shader</span>.<span style="color: #dcdcaa;">Find</span>(<span style="color: #ce9178;">"Custom/Segmentation"</span>);
        
        <span style="color: #c586c0;">if</span> (!<span style="color: #9cdcfe;">isMap</span>) 
        {
            <span style="color: #9cdcfe;">instanceColor</span> = <span style="color: #4ec9b0;">RandomUniqueColorGenerator</span>.<span style="color: #dcdcaa;">GetUniqueColor</span>();
            <span style="color: #9cdcfe;">partsColors</span> = <span style="color: #569cd6;">new</span> <span style="color: #4ec9b0;">List</span>&lt;(<span style="color: #4ec9b0;">Color</span> color, <span style="color: #569cd6;">string</span> name)&gt;();
        }
        
        <span style="color: #dcdcaa;">CachingMaterials</span>(<span style="color: #9cdcfe;">classColor</span>, <span style="color: #9cdcfe;">isMap</span>);
    }

    <span style="color: #569cd6;">private</span> <span style="color: #569cd6;">void</span> <span style="color: #dcdcaa;">SetOptionSegmentationMaterial</span>(<span style="color: #569cd6;">ref</span> <span style="color: #4ec9b0;">Material</span> <span style="color: #9cdcfe;">segMat</span>, <span style="color: #569cd6;">string</span> <span style="color: #9cdcfe;">objectName</span>)
    {
        <span style="color: #569cd6;">var</span> <span style="color: #9cdcfe;">randomColor</span> = <span style="color: #4ec9b0;">RandomUniqueColorGenerator</span>.<span style="color: #dcdcaa;">GetUniqueColor</span>();
        <span style="color: #9cdcfe;">partsColors</span>.<span style="color: #dcdcaa;">Add</span>((<span style="color: #9cdcfe;">randomColor</span>, <span style="color: #9cdcfe;">objectName</span>)); <span style="color: #6a9955;">// 부위별 색상 매핑</span>
        <span style="color: #9cdcfe;">segMat</span>.<span style="color: #dcdcaa;">SetColor</span>(<span style="color: #ce9178;">"_PartsColor"</span>, <span style="color: #9cdcfe;">randomColor</span>);
    }

    <span style="color: #569cd6;">public</span> <span style="color: #569cd6;">void</span> <span style="color: #dcdcaa;">ExecuteSegmentationMode</span>(<span style="color: #4ec9b0;">SegmentationMode</span> <span style="color: #9cdcfe;">mode</span>)
    {
        <span style="color: #9cdcfe;">segmentationMode</span> = <span style="color: #9cdcfe;">mode</span>;
        
        <span style="color: #9cdcfe;">rendererSets</span>.<span style="color: #dcdcaa;">ForEach</span>(<span style="color: #9cdcfe;">rendererSet</span> => 
        {
            <span style="color: #9cdcfe;">rendererSet</span>.<span style="color: #dcdcaa;">SetTargetSegmentationMode</span>(<span style="color: #9cdcfe;">segmentationMode</span>);
        });
    }
}</pre>
        </div>
        <p><strong>핵심 최적화:</strong> 런타임에 셰이더 모드만 변경하여 머티리얼 교체 없이 색상 전환</p>

        <h4>3. 커스텀 Segmentation Shader</h4>
        <div class="code-block">
<pre style="color: #d4d4d4; margin: 0;"><span style="color: #4ec9b0;">Shader</span> <span style="color: #ce9178;">"Custom/Segmentation"</span>
{
    <span style="color: #c586c0;">Properties</span>
    {
        <span style="color: #6a9955;">// Enum을 통한 모드 선택 (머티리얼 교체 없이 전환)</span>
        [<span style="color: #4ec9b0;">Enum</span>(<span style="color: #4fc1ff;">Default</span>, <span style="color: #b5cea8;">0</span>, <span style="color: #4fc1ff;">Instance</span>, <span style="color: #b5cea8;">1</span>, <span style="color: #4fc1ff;">Semantic</span>, <span style="color: #b5cea8;">2</span>, <span style="color: #4fc1ff;">Parts</span>, <span style="color: #b5cea8;">3</span>, <span style="color: #4fc1ff;">Panoptic</span>, <span style="color: #b5cea8;">4</span>, <span style="color: #4fc1ff;">Outline</span>, <span style="color: #b5cea8;">5</span>)] 
        _SegmentationMode(<span style="color: #ce9178;">"Segmentation Mode"</span>, <span style="color: #4ec9b0;">int</span>) = <span style="color: #b5cea8;">0</span>
        
        [<span style="color: #4ec9b0;">MainTexture</span>] _MainTex(<span style="color: #ce9178;">"Main Texture"</span>, <span style="color: #4ec9b0;">2D</span>) = <span style="color: #ce9178;">"white"</span> {}
        
        <span style="color: #6a9955;">// 각 모드별 색상 값</span>
        _DefaultColor(<span style="color: #ce9178;">"Default Color"</span>, <span style="color: #4ec9b0;">Color</span>) = (<span style="color: #b5cea8;">0</span>, <span style="color: #b5cea8;">0</span>, <span style="color: #b5cea8;">0</span>, <span style="color: #b5cea8;">1</span>)
        _InstanceColor(<span style="color: #ce9178;">"Instance Color"</span>, <span style="color: #4ec9b0;">Color</span>) = (<span style="color: #b5cea8;">1</span>, <span style="color: #b5cea8;">1</span>, <span style="color: #b5cea8;">1</span>, <span style="color: #b5cea8;">1</span>)
        _SemanticColor(<span style="color: #ce9178;">"Semantic Color"</span>, <span style="color: #4ec9b0;">Color</span>) = (<span style="color: #b5cea8;">1</span>, <span style="color: #b5cea8;">1</span>, <span style="color: #b5cea8;">1</span>, <span style="color: #b5cea8;">1</span>)
        _PartsColor(<span style="color: #ce9178;">"Parts Color"</span>, <span style="color: #4ec9b0;">Color</span>) = (<span style="color: #b5cea8;">1</span>, <span style="color: #b5cea8;">1</span>, <span style="color: #b5cea8;">1</span>, <span style="color: #b5cea8;">1</span>)
        _PanopticColor(<span style="color: #ce9178;">"Panoptic Color"</span>, <span style="color: #4ec9b0;">Color</span>) = (<span style="color: #b5cea8;">1</span>, <span style="color: #b5cea8;">1</span>, <span style="color: #b5cea8;">1</span>, <span style="color: #b5cea8;">1</span>)
        _OutlineColor(<span style="color: #ce9178;">"Outline Color"</span>, <span style="color: #4ec9b0;">Color</span>) = (<span style="color: #b5cea8;">0.8</span>, <span style="color: #b5cea8;">0.0</span>, <span style="color: #b5cea8;">0.0</span>, <span style="color: #b5cea8;">1</span>)
    }

    <span style="color: #c586c0;">SubShader</span>
    {
        <span style="color: #c586c0;">Pass</span>
        {
            <span style="color: #c586c0;">HLSLPROGRAM</span>
            <span style="color: #569cd6;">#pragma</span> vertex <span style="color: #dcdcaa;">vert</span>
            <span style="color: #569cd6;">#pragma</span> fragment <span style="color: #dcdcaa;">frag</span>
            
            <span style="color: #569cd6;">#include</span> <span style="color: #ce9178;">"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"</span>

            <span style="color: #6a9955;">// GPU 메모리 최적화를 위한 상수 버퍼</span>
            <span style="color: #c586c0;">CBUFFER_START</span>(<span style="color: #4ec9b0;">UnityPerMaterial</span>)
                <span style="color: #4ec9b0;">int</span> _SegmentationMode;
                <span style="color: #4ec9b0;">float4</span> _DefaultColor;
                <span style="color: #4ec9b0;">float4</span> _InstanceColor;
                <span style="color: #4ec9b0;">float4</span> _SemanticColor;
                <span style="color: #4ec9b0;">float4</span> _PartsColor;
                <span style="color: #4ec9b0;">float4</span> _PanopticColor;
                <span style="color: #4ec9b0;">float4</span> _OutlineColor;
                <span style="color: #4ec9b0;">float</span> _AlphaThreshold;
            <span style="color: #c586c0;">CBUFFER_END</span>

            <span style="color: #c586c0;">TEXTURE2D</span>(_MainTex);
            <span style="color: #c586c0;">SAMPLER</span>(sampler_MainTex);

            <span style="color: #569cd6;">struct</span> <span style="color: #4ec9b0;">Varyings</span>
            {
                <span style="color: #4ec9b0;">float4</span> positionCS : <span style="color: #4ec9b0;">SV_POSITION</span>;
                <span style="color: #4ec9b0;">float2</span> uv : <span style="color: #4ec9b0;">TEXCOORD0</span>;
                <span style="color: #4ec9b0;">float3</span> normalWS : <span style="color: #4ec9b0;">TEXCOORD1</span>;
                <span style="color: #4ec9b0;">float3</span> viewDirWS : <span style="color: #4ec9b0;">TEXCOORD2</span>;
            };

            <span style="color: #6a9955;">// Fragment Shader - 조건 분기 처리</span>
            <span style="color: #4ec9b0;">float4</span> <span style="color: #dcdcaa;">frag</span>(<span style="color: #4ec9b0;">Varyings</span> <span style="color: #9cdcfe;">input</span>) : <span style="color: #4ec9b0;">SV_Target</span>
            {
                <span style="color: #4ec9b0;">float4</span> <span style="color: #9cdcfe;">texColor</span> = <span style="color: #dcdcaa;">SAMPLE_TEXTURE2D</span>(_MainTex, sampler_MainTex, <span style="color: #9cdcfe;">input</span>.uv);
                <span style="color: #dcdcaa;">clip</span>(<span style="color: #9cdcfe;">texColor</span>.a - _AlphaThreshold);
                
                <span style="color: #6a9955;">// Early return 패턴으로 최적화</span>
                <span style="color: #6a9955;">// Uniform 분기: 모든 픽셀이 같은 모드를 사용하므로 효율적</span>
                <span style="color: #c586c0;">if</span> (_SegmentationMode == <span style="color: #b5cea8;">0</span>)
                {
                    <span style="color: #c586c0;">return</span> _DefaultColor;
                }
                <span style="color: #c586c0;">else if</span> (_SegmentationMode == <span style="color: #b5cea8;">1</span>)
                {
                    <span style="color: #c586c0;">return</span> _InstanceColor;
                }
                <span style="color: #c586c0;">else if</span> (_SegmentationMode == <span style="color: #b5cea8;">2</span>)
                {
                    <span style="color: #c586c0;">return</span> _SemanticColor;
                }
                <span style="color: #c586c0;">else if</span> (_SegmentationMode == <span style="color: #b5cea8;">3</span>)
                {
                    <span style="color: #c586c0;">return</span> _PartsColor;
                }
                <span style="color: #c586c0;">else if</span> (_SegmentationMode == <span style="color: #b5cea8;">4</span>)
                {
                    <span style="color: #c586c0;">return</span> _PanopticColor;
                }
                <span style="color: #c586c0;">else if</span> (_SegmentationMode == <span style="color: #b5cea8;">5</span>)
                {
                    <span style="color: #6a9955;">// Outline 모드: Fresnel 효과를 if-else로 처리</span>
                    <span style="color: #4ec9b0;">float3</span> <span style="color: #9cdcfe;">normalWS</span> = <span style="color: #dcdcaa;">normalize</span>(<span style="color: #9cdcfe;">input</span>.normalWS);
                    <span style="color: #4ec9b0;">float3</span> <span style="color: #9cdcfe;">viewDirWS</span> = <span style="color: #dcdcaa;">normalize</span>(<span style="color: #9cdcfe;">input</span>.viewDirWS);
                    <span style="color: #4ec9b0;">float</span> <span style="color: #9cdcfe;">fresnel</span> = <span style="color: #b5cea8;">1.0</span> - <span style="color: #dcdcaa;">saturate</span>(<span style="color: #dcdcaa;">dot</span>(<span style="color: #9cdcfe;">normalWS</span>, <span style="color: #9cdcfe;">viewDirWS</span>));
                    
                    <span style="color: #6a9955;">// Fresnel 임계값 기준으로 외곽선 색상 적용</span>
                    <span style="color: #c586c0;">if</span> (<span style="color: #9cdcfe;">fresnel</span> &gt; <span style="color: #b5cea8;">0.5</span>)
                    {
                        <span style="color: #c586c0;">return</span> _OutlineColor;
                    }
                    <span style="color: #c586c0;">else</span>
                    {
                        <span style="color: #c586c0;">return</span> <span style="color: #9cdcfe;">texColor</span>;
                    }
                }
                <span style="color: #c586c0;">else</span>
                {
                    <span style="color: #c586c0;">return</span> _DefaultColor; <span style="color: #6a9955;">// fallback</span>
                }
            }
            <span style="color: #c586c0;">ENDHLSL</span>
        }
    }
}</pre>
        </div>
        
        <!-- Shader 성능 테스트 영상 -->
        <div style="background: #e3f2fd; border: 2px solid #2196f3; border-radius: 10px; padding: 20px; margin: 20px 0;">
            <h5 style="color: #2c3e50; margin-top: 0; margin-bottom: 15px; text-align: center;">
                ⚡ Shader 모드 전환 성능 테스트
            </h5>
            
            <!-- 로컬 비디오 -->
            <div class="video-container">
                <video controls preload="metadata" poster="./assets/thumbnails/ShaderModeSwitchTest.png" data-video-id="ShaderModeSwitchTest">
                    <source src="./assets/videos/ShaderModeSwitchTest.mov" type="video/quicktime">
                    <source src="./assets/videos/ShaderModeSwitchTest.mp4" type="video/mp4">
                    브라우저가 비디오 재생을 지원하지 않습니다.
                </video>
                <div class="video-loading">로딩 중...</div>
            </div>
            <div class="video-views">조회수: <span class="view-count">0</span>회</div>
            
            <p style="margin-top: 15px; margin-bottom: 10px; color: #5a6c7d; text-align: center;">
                <strong>테스트 내용:</strong> 약 40개 객체 환경에서 실시간 셰이더 모드 전환 성능 검증
            </p>
            
            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-top: 15px;">
                <div style="background: #fff; border: 1px solid #e0e0e0; border-radius: 6px; padding: 10px; text-align: center;">
                    <p style="margin: 0; font-size: 9pt; color: #2196f3;">
                        <strong>🎯 테스트 조건</strong><br>
                        객체 수: 약 40개<br>
                        모드 전환: 실시간
                    </p>
                </div>
                <div style="background: #fff; border: 1px solid #e0e0e0; border-radius: 6px; padding: 10px; text-align: center;">
                    <p style="margin: 0; font-size: 9pt; color: #9c27b0;">
                        <strong>🔄 전환 가능 모드</strong><br>
                        Default ↔ Instance ↔ Semantic<br>
                        ↔ Parts ↔ Panoptic<br>
                        <span style="font-size: 8pt; color: #7f8c8d;">(순서 무관 자유 전환)</span>
                    </p>
                </div>
                <div style="background: #e8f5e9; border: 1px solid #4caf50; border-radius: 6px; padding: 10px; text-align: center;">
                    <p style="margin: 0; font-size: 9pt; color: #27ae60;">
                        <strong>✅ 성능 결과</strong><br>
                        FPS: 40~60+ 유지<br>
                        지연/버벅임: 없음<br>
                        <span style="font-size: 8pt;">빠른 전환에도 안정적</span>
                    </p>
                </div>
            </div>
            
            <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-radius: 6px; padding: 12px; margin-top: 15px;">
                <p style="margin: 0; font-size: 10pt; text-align: center;">
                    💡 <strong>핵심 성과:</strong> 다수 객체의 동시 색상 변경이 즉각적으로 반영되며, 
                    빠른 모드 전환에도 안정적인 성능 유지
                </p>
            </div>
        </div>

        <h2>📊 성능 개선 결과</h2>
        
        <div class="key-points" style="background: #f3e5f5; margin-bottom: 20px;">
            <h4 style="margin-top: 0; color: #7b1fa2;">⚙️ 테스트 환경 사양</h4>
            <ul>
                <li>GPU: NVIDIA RTX 3070 (8GB VRAM)</li>
                <li>CPU: Intel i7-10700K @ 3.8GHz</li>
                <li>RAM: 32GB DDR4 3200MHz</li>
                <li>Unity: 2022.3.8f1 LTS with HDRP 14.0.8</li>
                <li>해상도: 1920x1080 (Full HD)</li>
            </ul>
        </div>
        
        <table>
            <thead>
                <tr>
                    <th>지표</th>
                    <th>기존 방식</th>
                    <th>개선 방식</th>
                    <th>개선율</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>객체 1개 처리 시간</td>
                    <td>0.5초</td>
                    <td>0.1초 이하</td>
                    <td class="improvement">5배 향상</td>
                </tr>
                <tr>
                    <td>객체 100개 처리 시간</td>
                    <td>50초</td>
                    <td>5초</td>
                    <td class="improvement">10배 향상</td>
                </tr>
                <tr>
                    <td>GPU-CPU 전송 횟수</td>
                    <td>객체 수만큼</td>
                    <td>1회 고정</td>
                    <td class="improvement">N배 감소</td>
                </tr>
                <tr>
                    <td>메모리 사용량</td>
                    <td>가변적 증가</td>
                    <td>일정 수준 유지</td>
                    <td class="improvement">안정화</td>
                </tr>
            </tbody>
        </table>

        <h2>🎯 기술적 도전과 해결</h2>
        
        <h3>1. 처리 속도 개선을 위한 다양한 기술적 시도</h3>
        <div class="result-card">
            <h4>시도한 최적화 방법들:</h4>
            <ul style="list-style-type: disc; padding-left: 25px;">
                <li><strong>Compute Shader + Job System:</strong> 병렬 처리로 속도 개선 시도 → 데이터 정확성 문제로 포기</li>
                <li><strong>MaterialPropertyBlock:</strong> 머티리얼 인스턴싱 없이 속성 변경 시도 → HDRP에서 제한적 지원으로 사용 불가</li>
                <li><strong>머티리얼 인스턴싱:</strong> 동적 머티리얼 생성 → 메모리 사용량 급증 문제</li>
            </ul>
            
            <h4 style="margin-top: 20px;">최종 해결책:</h4>
            <ul style="list-style-type: disc; padding-left: 25px;">
                <li>커스텀 Unlit Shader로 경량화된 머티리얼 생성</li>
                <li>Enum 기반 모드 시스템으로 런타임 색상 전환</li>
                <li>단일 셰이더에서 모든 세그멘테이션 타입 지원</li>
            </ul>
        </div>

        <h3>2. 데이터 정확성 보장</h3>
        <div class="process-flow">
            <h4>검증 프로세스</h4>
            <ol>
                <li><strong>단위 테스트:</strong> 기능별 개별 씬 구성하여 검증</li>
                <li><strong>통합 테스트:</strong> 실제 환경에서 전체 프로세스 검증</li>
                <li><strong>출력물 신뢰성:</strong> OpenCV 결과값과 실제 객체 데이터 정합성 확인</li>
            </ol>
        </div>

        <h2>🏆 핵심 기술 성과</h2>
        
        <!-- 최종 결과물 데모 영상 -->
        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border: 3px solid #fff; border-radius: 15px; padding: 25px; margin: 30px 0; box-shadow: 0 10px 40px rgba(102, 126, 234, 0.4);">
            <h3 style="color: white; margin-top: 0; margin-bottom: 20px; text-align: center; font-size: 18pt;">
                🎯 최종 결과물 - AI 데이터 생성 시스템 실행
            </h3>
            
            <!-- 로컬 비디오 -->
            <div class="video-container" style="box-shadow: 0 8px 25px rgba(0,0,0,0.3);">
                <video controls preload="metadata" poster="./assets/thumbnails/Result.png" data-video-id="Result">
                    <source src="./assets/videos/Result.mov" type="video/quicktime">
                    <source src="./assets/videos/Result.mp4" type="video/mp4">
                    브라우저가 비디오 재생을 지원하지 않습니다.
                </video>
                <div class="video-loading">로딩 중...</div>
            </div>
            <div class="video-views">조회수: <span class="view-count">0</span>회</div>
            
            <div style="background: rgba(255,255,255,0.95); border-radius: 10px; padding: 20px; margin-top: 20px;">
                <p style="margin-bottom: 15px; color: #2c3e50; text-align: center; font-weight: 600;">
                    📊 시스템 실행 결과 - 전체 파이프라인 데모
                </p>
                
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px;">
                    <div style="background: #f8f9fa; border-left: 4px solid #3498db; padding: 15px; border-radius: 5px;">
                        <h4 style="margin-top: 0; color: #2980b9; font-size: 11pt;">📥 입력 프로세스</h4>
                        <ul style="margin: 0; padding-left: 20px; font-size: 10pt; color: #5a6c7d;">
                            <li>3D 씬 구성 및 객체 배치</li>
                            <li>세그멘테이션 모드 설정</li>
                            <li>카메라 앵글 자동 조정</li>
                        </ul>
                    </div>
                    
                    <div style="background: #f8f9fa; border-left: 4px solid #27ae60; padding: 15px; border-radius: 5px;">
                        <h4 style="margin-top: 0; color: #27ae60; font-size: 11pt;">📤 출력 데이터</h4>
                        <div style="font-size: 10pt; color: #5a6c7d;">
                            <strong style="color: #27ae60;">이미지 데이터:</strong>
                            <ul style="margin: 5px 0; padding-left: 20px;">
                                <li>RGB 원본 이미지</li>
                                <li>Instance (객체별)</li>
                                <li>Semantic (클래스별)</li>
                                <li>Panoptic (Instance+Semantic)</li>
                                <li>Bounding Box</li>
                                <li>Depth / Normal Map</li>
                            </ul>
                            <strong style="color: #27ae60;">텍스트 데이터:</strong>
                            <ul style="margin: 5px 0; padding-left: 20px;">
                                <li>YOLO 형식</li>
                                <li>Pascal VOC 형식</li>
                                <li>COCO 형식</li>
                            </ul>
                        </div>
                    </div>
                </div>
                
                <div style="background: linear-gradient(90deg, #e74c3c 0%, #f39c12 25%, #f1c40f 50%, #2ecc71 75%, #3498db 100%); 
                            height: 4px; 
                            border-radius: 2px; 
                            margin: 20px 0;">
                </div>
                
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px; text-align: center;">
                    <div style="background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); 
                                color: white; 
                                padding: 15px; 
                                border-radius: 10px;
                                box-shadow: 0 4px 15px rgba(0,0,0,0.1);">
                        <p style="font-size: 24pt; font-weight: bold; margin: 0;">10x</p>
                        <p style="font-size: 10pt; margin: 5px 0 0 0;">성능 향상</p>
                        <p style="font-size: 8pt; margin: 5px 0 0 0; opacity: 0.9;">기존 대비 처리 속도 대폭 개선</p>
                    </div>
                    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
                                color: white; 
                                padding: 15px; 
                                border-radius: 10px;
                                box-shadow: 0 4px 15px rgba(0,0,0,0.1);">
                        <p style="font-size: 24pt; font-weight: bold; margin: 0;">100%</p>
                        <p style="font-size: 10pt; margin: 5px 0 0 0;">데이터 정확도</p>
                        <p style="font-size: 8pt; margin: 5px 0 0 0; opacity: 0.9;">픽셀 단위 정밀한 라벨링</p>
                    </div>
                </div>
                
                <div style="background: #e8f5e9; 
                            border-radius: 8px; 
                            padding: 15px; 
                            margin-top: 20px;
                            text-align: center;">
                    <p style="margin: 0; font-size: 11pt; color: #27ae60;">
                        <strong>✨ 핵심 성과:</strong> 다양한 AI 학습 포맷 지원으로 즉시 활용 가능한 고품질 데이터셋 생성
                    </p>
                </div>
            </div>
        </div>
        
        <div class="key-points" style="background: #e8f5e9;">
            <h3 style="margin-top: 0; color: #27ae60;">1. 셰이더 기반 최적화</h3>
            <ul>
                <li>단일 셰이더로 5가지 세그멘테이션 모드 지원</li>
                <li>GPU 메모리 블록 최적화로 데이터 전송 효율성 향상</li>
                <li>런타임 모드 전환으로 머티리얼 교체 오버헤드 제거</li>
            </ul>
        </div>

        <div class="key-points" style="background: #fff3e0;">
            <h3 style="margin-top: 0; color: #f39c12;">2. 알고리즘 개선</h3>
            <ul>
                <li>객체별 순차 처리 → 배치 처리로 패러다임 전환</li>
                <li>ReadPixels 호출 최소화</li>
                <li>색상 기반 병렬 세그멘테이션으로 처리 시간 대폭 단축</li>
            </ul>
        </div>

        <div class="key-points" style="background: #fce4ec;">
            <h3 style="margin-top: 0; color: #e91e63;">3. 실무 적용 가능성</h3>
            <ul>
                <li>대규모 AI 학습 데이터셋 빠른 구축 가능</li>
                <li>다양한 출력 포맷 지원 (YOLO, COCO, Pascal VOC)</li>
                <li>픽셀 단위 정확도로 고품질 라벨링 데이터 제공</li>
            </ul>
        </div>
    </div>

    <script>
        // 비디오 로딩 표시 및 조회수 처리
        document.addEventListener('DOMContentLoaded', function() {
            const videos = document.querySelectorAll('video');
            
            videos.forEach(video => {
                const container = video.closest('.video-container');
                const loading = container.querySelector('.video-loading');
                const viewsElement = container.nextElementSibling?.querySelector('.view-count');
                const videoId = video.getAttribute('data-video-id');
                
                // 로딩 시작
                video.addEventListener('loadstart', function() {
                    if(loading) loading.style.display = 'block';
                });
                
                // 로딩 완료
                video.addEventListener('canplay', function() {
                    if(loading) loading.style.display = 'none';
                });
                
                // 에러 처리
                video.addEventListener('error', function() {
                    if(loading) {
                        loading.textContent = '비디오를 로드할 수 없습니다';
                        loading.style.color = '#e74c3c';
                    }
                });
                
                // 비디오 조회수 처리 (CountAPI 사용 - 모든 사용자 공유)
                if(videoId && viewsElement) {
                    // CountAPI에서 조회수 가져오기
                    fetch(`https://api.countapi.xyz/get/suengwone-portfolio/video-${videoId}`)
                        .then(response => response.json())
                        .then(data => {
                            const views = data.value || 0;
                            viewsElement.textContent = views.toLocaleString();
                        })
                        .catch(() => {
                            // 키가 없으면 생성
                            fetch(`https://api.countapi.xyz/create?namespace=suengwone-portfolio&key=video-${videoId}&value=0`)
                                .then(() => viewsElement.textContent = '0');
                        });
                    
                    // 재생 시작 시 조회수 증가
                    let hasPlayed = false;
                    video.addEventListener('play', function() {
                        if(!hasPlayed) {
                            hasPlayed = true;
                            
                            // CountAPI로 조회수 증가
                            fetch(`https://api.countapi.xyz/hit/suengwone-portfolio/video-${videoId}`)
                                .then(response => response.json())
                                .then(data => {
                                    viewsElement.textContent = data.value.toLocaleString();
                                    
                                    // Google Analytics 이벤트 전송
                                    if(typeof gtag !== 'undefined') {
                                        gtag('event', 'video_play', {
                                            'video_title': videoId,
                                            'video_views': data.value
                                        });
                                    }
                                });
                        }
                    });
                }
            });
        });
    </script>

    <!-- Google Analytics 기반 방문자 카운터 -->
    <script>
        // Google Analytics Reporting API를 사용한 실시간 방문자 수 표시
        // 주의: 이 방법은 Google Analytics 데이터에 접근하기 위한 설정이 필요합니다
        
        (function() {
            // 간단한 방문자 카운터 (CountAPI 사용 - 모든 사용자 공유)
            // 총 방문자 수 가져오기
            fetch(`https://api.countapi.xyz/hit/suengwone-portfolio/visits`)
                .then(response => response.json())
                .then(data => {
                    const totalVisits = data.value;
                    
                    // 오늘 방문자 수는 Google Analytics에서 가져오거나 추정
                    // 실제로는 서버가 필요하지만, 간단한 추정치 표시
                    const todayVisits = Math.max(1, Math.floor(totalVisits * 0.05)); // 총 방문의 5% 추정
                    
                    // 카운터 표시
                    document.getElementById('counter-content').innerHTML = `
                        <div class="counter-item">
                            <span class="counter-label">오늘:</span>
                            <span class="counter-value">${todayVisits.toLocaleString()}</span>
                        </div>
                        <div class="counter-item">
                            <span class="counter-label">전체:</span>
                            <span class="counter-value">${totalVisits.toLocaleString()}</span>
                        </div>
                    `;
                })
                .catch(error => {
                    console.error('카운터 로드 실패:', error);
                    // 실패 시 기본값 표시
                    document.getElementById('counter-content').innerHTML = `
                        <div class="counter-item">
                            <span class="counter-label">전체:</span>
                            <span class="counter-value">-</span>
                        </div>
                    `;
                });
            
            // Google Analytics 페이지뷰 이벤트
            if(typeof gtag !== 'undefined') {
                gtag('event', 'page_view', {
                    page_location: window.location.href,
                    page_title: document.title
                });
            }
        })();
    </script>
</body>
</html>